C51 COMPILER V9.60.7.0   TASK                                                              01/05/2026 22:26:26 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TASK
OBJECT MODULE PLACED IN .\Objects\task.obj
COMPILER INVOKED BY: E:\AAAAAA\Keil_v5\C51\BIN\C51.EXE Bare-MetalMultitasking\task.c LARGE OPTIMIZE(8,SPEED) BROWSE INCD
                    -IR(.\User;.\Lib;.\Hardware;.\App;.\Bare-MetalMultitasking;.\Hardware\I2Csoft_oled) DEBUG OBJECTEXTEND PRINT(.\Listings\t
                    -ask.lst) OBJECT(.\Objects\task.obj)

line level    source

   1          #include "task.h"
   2          #include "App.h"
   3          
   4          u8 task_lock_state = TASK_STATE_UNLOCK;
   5          
   6          void Task_init(){
   7   1                      Keys_init();
   8   1      #if EC11
                              EC11_init();
              #endif
  11   1                      OLED_Init();
  12   1      }
  13          
  14          Task_t task_list[] = {
  15          //                         state         task_cnt     task_period      callback
  16                                  {TASK_STATE_STOP,                100,         50,       App_Keys_task},
  17                                  //{TASK_STATE_STOP,              10,          250,      StandbyAnimationWave},
  18          };
  19          
  20          // 任务数量
  21          u8 task_len = sizeof(task_list) / sizeof(task_list[0]);
  22          
  23          
  24          // 修改全局计数值(在中断函数里1ms调用一次, 用于任务切换)
  25          void Task_switch_handler(void){
  26   1                      u8 i = 0;
  27   1          for(i = 0; i < task_len; i++) {
  28   2              Task_t* task = &task_list[i];
  29   2              
  30   2              // 如果任务是上锁状态了, 直接跳过当前循环
  31   2              if(task_lock_state == TASK_STATE_LOCK){
  32   3                  continue;
  33   3              }                       
  34   2              // 如果任务计数值task_cnt不是0, 减1
  35   2              if(task->task_cnt) task->task_cnt--;
  36   2              
  37   2              // 计数值为0, 切换任务为可运行状态
  38   2              if(task->task_cnt == 0){
  39   3                  // 切换任务状态, 不在这里(在终端exec)运行
  40   3                  task->state = TASK_STATE_RUN;
  41   3                  // 重置count计数值
  42   3                  task->task_cnt = task->task_period;
  43   3              }
  44   2          }
  45   1      }
  46          
  47          
  48          // 任务执行的函数
  49          void Task_exec_handler(void){   // 每时每刻 main函数中while(1)运行
  50   1      
  51   1          u8 i = 0;    
  52   1          for(i = 0; i < task_len; i++){ 
  53   2                                      Task_t *task = &task_list[i];
C51 COMPILER V9.60.7.0   TASK                                                              01/05/2026 22:26:26 PAGE 2   

  54   2                              
  55   2                                      // 判断任务是否是RUN 可运行状态
  56   2              if(task->state == TASK_STATE_RUN){
  57   3                                                // 重置任务为停止状态
  58   3                                                      task->state = TASK_STATE_STOP; 
  59   3                  // 真正执行函数任务的地方
  60   3                  task->callback();
  61   3              }
  62   2          }
  63   1      }
  64           
  65          // 上锁任务
  66          void Task_Lock(){
  67   1          task_lock_state = TASK_STATE_LOCK;
  68   1      }
  69          
  70          // 解锁任务
  71          void Task_Unlock(){
  72   1          task_lock_state = TASK_STATE_UNLOCK;    
  73   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    295    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     14       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
